<!DOCTYPE html>
<html lang="en">
<head>
<link rel="icon" href="img/icon.png" async>
<meta charset="UTF-8">
<meta http-equiv="Content-Language" content="de, en">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta name="description" content="Jump and Run Game prototyp.">
<meta name="robots" content="noindex,nofollow">
<meta name="keywords" lang="en" content="game, canvas, jump and run, boring">
<meta name="keywords" lang="de" content="Spiel, canvas, Jump and Run, langeweile">
<meta name="format-detection" content="telephone=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<title>yet another mario klon</title>
<noscript>Your browser does not support JavaScript!</noscript>
<script src="config.js"></script>
<script src="settingsconfig.js"></script>
<script src="stats.js"></script>
<script src="keys.js"></script>
<!--<script id="neat" src="./lib/NEAT_browser.js"></script>-->
<script id="manage">
//getting all functions of loadet script
'use strict';
console.groupCollapsed("starting");
console.info("selftest start")
let totest=["Worker","Performance","crypto","requestAnimationFrame","JSON","Float64Array","Set","Path2D","CanvasRenderingContext2D","URL","IdleDeadline","Image","FileReader","Blob","OffscreenCanvas","AudioContext","SharedArrayBuffer"]
let vendors=["webkit","moz","o","ms"]
for(let i of totest){
    if(!(i in window)){
        console.warn(i+" not found")
        for(let i1 of vendors){
            let prefixedversion=i1+i.charAt(0).toUpperCase()+i.slice(1)
            if(prefixedversion in window){
                window[i]=window[prefixedversion]
                console.log("found prefixed "+prefixedversion)
            }
        }

    }
}
console.info("selftest finished")
console.info("backupfunction load")
//https://stackoverflow.com/questions/2116558/fastest-method-to-replace-all-instances-of-a-character-in-a-string
if(!("requestAnimationFrame" in window)){
    String.prototype.replaceAll = function(str1, str2, ignore){
        return this.replace(new RegExp(str1.replace(/([\/\,\!\\\^\$\{\}\[\]\(\)\.\*\+\?\|\<\>\-\&])/g,"\\$&"),(ignore?"gi":"g")),(typeof(str2)=="string")?str2.replace(/\$/g,"$$$$"):str2);
    } 
    console.log("use use replaceAll")
}
if(!("requestAnimationFrame" in window)){window.requestAnimationFrame=function(callback){window.setTimeout(callback, 1000 / 60)};console.log("use setTimeout")}
if(!("OffscreenCanvas" in window)){
    console.warn("use canvas as offscreencanvas")
    window.OffscreenCanvas=function(w=0,h=0){
/** @type {HTMLCanvasElement} a */
        let a=document.createElement("Canvas")
        a.width=w
        a.height=h
        return a
    }
}else{
    try{
        (new OffscreenCanvas(0,0)).getContext("2d");
    }catch(err){
        console.warn("offscreencanvas context 2d dont work")
        window.OffscreenCanvas=function(w=0,h=0){
/** @type {HTMLCanvasElement} a */
        let a=document.createElement("Canvas")
        a.width=w
        a.height=h
        return a}
    }
}
if(!("SharedArrayBuffer" in window)){
    console.warn("use ArrayBuffer as SharedArrayBuffer")
    window.SharedArrayBuffer=ArrayBuffer
}
if(!("allSettled" in Promise)){
    console.warn("use Promise.allSettled fallback")
    Promise.allSettled = function (promises) {
      let mappedPromises = promises.map((p) => {
        return p
          .then((value) => {
            return {
              status: 'fulfilled',
              value,
            };
          })
          .catch((reason) => {
            return {
              status: 'rejected',
              reason,
            };
          });
      });
      return Promise.all(mappedPromises);
    };
}
console.info("backupfunction finished")

console.info("Promises start")
for(let i=0;i<scriptload.length;i++){
    promall[i]=new Promise((r,j)=>[promallres[i],promallrej[i]]=[r,j]);
    promall[i].res=false
    promall[i].then(()=>{promall[i].res=true;console.info(i+"loaded "+scriptload[i])},()=>{console.warn(i+"couldnt load "+scriptload[i])})
}
console.group("Promises")


//function for that that i dont need to make the same code over and over

Promise.all([promall[0],promall[1],promall[8],promall[22],promall[23]]).then(()=>{defaultarrload();})
Promise.all(promall).then(()=>{console.info("all loaded")},()=>{console.warn("couldnt load all")})

document.addEventListener('DOMContentLoaded',()=>{
    Promise.all([promall[0]]).then(()=>{
        if(window.Worker&&!collmapnowebworker){//das nur starten wen man freie zeit hat oder bei start
            workerpk=new Worker(window.URL.createObjectURL(new Blob([document.querySelector('#worker1').textContent], { type: "text/javascript" })));
            workercol=new Worker(window.URL.createObjectURL(new Blob([document.querySelector('#worker2').textContent], { type: "text/javascript" })));
        }
        document.getElementById("start").onclick=()=>{start('ani')};
        document.getElementById("keymap").onclick=()=>{menu(),mswitch()};
        document.getElementById("save").onclick=()=>{loadandsave(),mswitch()};
        document.getElementById("settings").onclick=()=>{setting(),mswitch()};
        document.getElementById("webrtc").onclick=()=>{webrtcgui();mswitch()}
        document.getElementById("build").onclick=()=>{start('build')};
        document.getElementById("close").onclick=()=>{websiteclose()};

        document.getElementById("keymap").disabled=false;
        document.getElementById("settings").disabled=false;
        document.getElementById("close").disabled=false;
        if(!disablemenucontrolls)menucontrolls()
        if(weather)getweather()
    })
    Promise.all([promall[0],promall[1],promall[8],promall[22],promall[23]]).then(()=>{
        if(document.getElementById("save"))document.getElementById("save").disabled=false
    })
    Promise.all([promall[0],promall[1],promall[6],promall[8],promall[15],promall[16],promall[22],promall[23],promall[24]]).then(()=>{
        if(document.getElementById("start"))document.getElementById("start").disabled=false
        urlparams()
    })
    Promise.all([promall[0],promall[1],promall[5],promall[8],promall[22],promall[23]]).then(()=>{
        if(document.getElementById("build"))document.getElementById("build").disabled=false
    })
    Promise.all([promall[0],promall[10],promall[11],promall[12]]).then(()=>{
        if(typeof(multiplayerid)=="undefined")genid()
        if(document.getElementById("webrtc"))document.getElementById("webrtc").disabled=false
    })
    Promise.all([promall[0],promall[9]]).then(()=>{
        if(document.getElementById("keymap"))document.getElementById("keymap").title=tooltips.hasOwnProperty("buttom")&&tooltips.buttom.hasOwnProperty("keymap")?tooltips.buttom.keymap:""
        if(document.getElementById("settings"))document.getElementById("settings").title=tooltips.hasOwnProperty("buttom")&&tooltips.buttom.hasOwnProperty("settings")?tooltips.buttom.settings:""
    })
    Promise.all([promall[0],promall[1],promall[8],promall[9],promall[22],promall[23]]).then(()=>{
        if(document.getElementById("save"))document.getElementById("save").title=tooltips.hasOwnProperty("buttom")&&tooltips.buttom.hasOwnProperty("save")?tooltips.buttom.save:""
    })
    Promise.all([promall[0],promall[1],promall[6],promall[8],promall[9],promall[22],promall[23]]).then(()=>{
        if(document.getElementById("start"))document.getElementById("start").title=tooltips.hasOwnProperty("buttom")&&tooltips.buttom.hasOwnProperty("start")?tooltips.buttom.start:""
    })
    Promise.all([promall[0],promall[1],promall[5],promall[8],promall[9],promall[22],promall[23]]).then(()=>{
        if(document.getElementById("build"))document.getElementById("build").title=tooltips.hasOwnProperty("buttom")&&tooltips.buttom.hasOwnProperty("build")?tooltips.buttom.build:""
    })
    Promise.all([promall[0],promall[9],promall[10],promall[11],promall[12]]).then(()=>{
        if(document.getElementById("webrtc"))document.getElementById("webrtc").title=tooltips.hasOwnProperty("buttom")&&tooltips.buttom.hasOwnProperty("webrtc")?tooltips.buttom.webrtc:""
    })
    Promise.all([promall[0],promall[1],promall[8],promall[10],promall[11],promall[12],promall[22],promall[23]]).then(()=>{
        if(!multiplayerjustlisten&&multiplayer&&!multiplayerstartet)initializeconnections()
    })
    Promise.all(promall).then(()=>{//brauch da net jede
        specialevents()
    })
    Promise.all([promall[0],promall[9]]).then(()=>{
        for(let i of document.querySelectorAll(".menu")){
            if(tooltips.hasOwnProperty("buttomname")&&tooltips.buttomname.hasOwnProperty(i.id))i.textContent=tooltips.buttomname[i.id]
        }
    })
})
Promise.allSettled(promall).then(()=>{console.groupEnd();console.info("Promises finished");console.groupEnd();promall[0].then(()=>messurefps())})
//bekomme alle selbst geschriebene functionen
//for(var i in this) {
//    try {
//	    if((typeof this[i]).toString()=="function"&&this[i].toString().indexOf("native")==-1){
//        }
//    } catch(e){}
//}
for(let i=0;i<scriptload.length;i++){
    var script = document.createElement("script");
    script.src = scriptload[i]
    if(scriptloadinportant.includes(scriptload[i]))script.importance="high"
    script.async=true
    script.onerror="promallrej["+i+"]()"
    document.head.appendChild(script);
}
</script>
<!--<script src="http://webrtc.github.io/adapter/adapter-latest.js"></script><!--fixes bugs in browser that they dont follow specs-->

<script id="worker1" async type="javascript/worker">
//js
self.onmessage=(e)=>{//wasser map erstelln
    if("debugchanel" in e.data){
        e.data.debugchanel.onmessage=e1=>{
            let str=""
            console.log("%cwebworker run: "+e1.data,'color: orange')
            try{str=eval(e1.data);console.log(str)}catch(e1){e.data.debugchanel.postMessage(e1)}
            try{e.data.debugchanel.postMessage(str)}catch(e1){e.data.debugchanel.postMessage(e1)}
        }
        return
    }
    pathmap(e.data[0],e.data[1],e.data[2],e.data[3],e.data[4])
}
function pathmap(minx,miny,maxx,maxy,test){
    const col=new Uint32Array((maxx-minx)*(maxy-miny)).fill(Number.MAX_SAFE_INTEGER)
    let Old=1
    let list=[]
    for(let i of test){
        const minxs=Math.trunc(Math.min(...i.x))
        const minys=Math.trunc(Math.min(...i.y))
        const maxxs=Math.trunc(Math.max(...i.x))+1
        const maxys=Math.trunc(Math.max(...i.y))+1
        const colobj1=new Uint8Array(Math.floor(maxys-minys)*Math.floor(maxxs-minxs))
        for(let i0=0,i1=1;i0<i.x.length;i0++,i1=(i0+1)%i.x.length){
            let winkel=Math.atan2(i.y[i0]-i.y[i1],i.x[i0]-i.x[i1])
            for(let ix=i.x[i0],iy=i.y[i0];Math.round(ix)!=Math.round(i.x[i1])||Math.round(iy)!=Math.round(i.y[i1]);ix-=Math.cos(winkel),iy-=Math.sin(winkel)){
                if(i.mode==2)list.push((Math.round(iy)-miny)*(maxx-minx)+Math.round(ix)-minx);
                if(i.mode!=1)col[(Math.round(iy)-miny)*(maxx-minx)+Math.round(ix)-minx]=0
                colobj1[(Math.round(iy)-minys)*(maxxs-minxs)+Math.round(ix)-minxs]=1
            }
        }
        for(let iy=0;iy<maxys-minys;iy++){
            for(let ix=0;ix<maxxs-minxs;ix++){
                if(colobj1[iy*Math.floor(maxxs-minxs)+ix]==1&&colobj1[iy*Math.floor(maxxs-minxs)+Math.min(ix+1,Math.floor(maxxs-minxs))]==0){
                    let allowed=false
                    for(let ix1=ix+1;ix1<(maxxs-minxs);ix1++){
                        if(colobj1[iy*Math.floor(maxxs-minxs)+ix1]==1){allowed=true;break}
                    }
                    if(!allowed)continue
                    for(let ix1=ix+1;ix1<(maxxs-minxs)&&colobj1[iy*(maxxs-minxs)+ix1]==0;ix1++){
                        if(i.mode==2)list.push((Math.round(iy)+minys-miny)*(maxx-minx)+Math.round(ix)+minxs-minx);
                        if(i.mode!=1)col[(Math.round(iy)+minys-miny)*(maxx-minx)+Math.round(ix)+minxs-minx]=0
                    }
                }
            }
        }
    }
    while (true) {
        const list1=new Set(list)
        list=[]
        Old++
        for (let a1 of list1){
            let at0=Math.trunc(a1/(maxx-minx)) //y
            let at1=Math.trunc(a1%(maxx-minx)) //x
            col[a1]=Old
            if (at0+1<=(maxy-miny)&&col[a1+(maxx-minx)]==0)list.push(a1+(maxx-minx))
            if (at1+1<=(maxx-minx)&&col[a1+1]==0)list.push(a1+1)
            if (at0-1>=0&&col[a1-(maxx-minx)]==0)list.push(a1-(maxx-minx))
            if (at1-1>=0&&col[a1-1]==0)list.push(a1-1)
        }
        if(list1.size==0){
            const colo=col.buffer
            postMessage(colo,[colo]);
            break
        }
    }
}
//!js
</script>


<script id="worker2" async type="javascript/worker">
//js
let canvasgl,
    gl,
    shaderProgram,
    WEBGLmultidraw,
    WEBGLcbufferfloat,
    coordinates2,
    num,
    midle,
    objnum,
    max,
    frame,
    render,
    vao,
    enablewebgl=true,
    shared=false,
    col,
    colobj,
    objnumout


self.onmessage=(e)=>{
    if("debugchanel" in e.data){
        e.data.debugchanel.onmessage=e1=>{
            let str=""
            console.log("%cwebworker run: "+e1.data,'color: orange')
            try{str=eval(e1.data);console.log(str)}catch(e1){e.data.debugchanel.postMessage(e1)}
            try{e.data.debugchanel.postMessage(str)}catch(e1){e.data.debugchanel.postMessage(e1)}
        }
        return
    }
    if(e.data.length==3){
        col=new Uint32Array(e.data[0])
        colobj=new Uint8Array(e.data[1])
        objnumout=new Uint8Array(e.data[2])
        shared=true
    }
    if(!shared){
        col=new Uint32Array((e.data[3]-e.data[1])*(e.data[2]-e.data[0]))
        colobj=new Uint8Array((e.data[3]-e.data[1])*(e.data[2]-e.data[0]))
        objnumout=new Uint8Array((e.data[3]-e.data[1])*(e.data[2]-e.data[0]))
    }
    //teste noch ob shader alles geht
    if(enablewebgl&&e.data[5]){
        gpuwork(e.data[0],e.data[1],e.data[2],e.data[3],e.data[4],col,colobj,objnumout)
    }else{
        work(e.data[0],e.data[1],e.data[2],e.data[3],e.data[4],col,colobj,objnumout)
    }
    if(shared){
        postMessage("finish");
    }else{
        const colb=col.buffer
        const colbobj=colobj.buffer
        const objnumoutb=objnumout.buffer
        postMessage([colb,colbobj,objnumoutb],[colb,colbobj,objnumoutb]);//transferobj nehmen
    }
    //postMessage(colb,[colb]);//transferobj nehmen
}
function work(minx,miny,maxx,maxy,myRect,col,colobj,objnumout){
    
    let offscall=false
    if(typeof(OffscreenCanvas)=="function"){
        offscall=true
        //tests auf offscreen das auch context 2d geht
        try{
            (new OffscreenCanvas(0,0)).getContext("2d");
        }catch(err){
            offscall=false
        }
    }
    for (let num in myRect){
        let i=myRect[num]
        if(i.invisible)continue
        //wen ich im array bin dan mach mir tiefe werte geben
        if(typeof(i.x)=="object"){
            if(offscall||typeof(Canvas)=="function"){
                const minxs=Math.min(...i.x)
                const minys=Math.min(...i.y)
                const maxxs=Math.max(...i.x)
                const maxys=Math.max(...i.y)
                let canvas
                if(offscall){
                    canvas=new OffscreenCanvas(Math.round(maxxs-minxs),Math.round(maxys-minys))
                }else{
                    canvas=document.createElement("Canvas")
                    canvas.width=Math.round(maxxs-minxs)
                    canvas.height=Math.round(maxys-minys)
                }
                ctx=canvas.getContext("2d");
                ctx.moveTo(i.x[0]-minxs,i.y[0]-minys)
                for (let i1=1;i1<i.x.length;i1++){
                    ctx.lineTo(i.x[i1]-minxs,i.y[i1]-minys)
                }
                for (let y=0;y<=maxys-minys;y++) {//draw obj with canvas
                    for (let x=0;x<=maxxs-minxs;x++) {
                        if(ctx.isPointInPath(x,y)){
                            col[(y+minys-miny)*(maxx-minx)+x+minxs-minx]=((maxx-minx)*(maxy-miny)+Math.min(y-minys,maxys-y,x-minxs,maxxs-x))|0
                            colobj[(y+minys-miny)*(maxx-minx)+x+minxs-minx]=(+num+1)
                            objnumout[(y+minys-miny)*(maxx-minx)+x+minxs-minx]=i.objnum
                        }
                    }
                }
            }else{//if there is no canvas suport render it with math
                const minxs=Math.min(...i.x)
                const minys=Math.min(...i.y)
                const maxxs=Math.max(...i.x)+1
                const maxys=Math.max(...i.y)+1
                const colobj1=new Uint8Array(Math.floor(maxys-minys)*Math.floor(maxxs-minxs))

                for(let i0=0,i1=1;i0<i.x.length;i0++,i1=(i0+1)%i.x.length){
                    let winkel=Math.atan2(i.y[i0]-i.y[i1],i.x[i0]-i.x[i1])
                    for(let ix=i.x[i0],iy=i.y[i0];Math.round(ix)!=Math.round(i.x[i1])||Math.round(iy)!=Math.round(i.y[i1]);ix-=Math.cos(winkel),iy-=Math.sin(winkel)){
                        colobj1[(Math.round(iy)-minys-1)*(maxxs-minxs)+Math.round(ix)-minxs]=1
                        col[(Math.round(iy)+minys-miny)-1*(maxx-minx)+Math.round(ix)+minxs-minx]=((maxx-minx)*(maxy-miny)+Math.min(iy,maxys-(iy+minys),ix,maxxs-(ix+minxs)))|0
                        colobj[(Math.round(iy)+minys-miny-1)*(maxx-minx)+Math.round(ix)+minxs-minx]=(+num+1)
                        objnumout[(Math.round(iy)+minys-miny-1)*(maxx-minx)+Math.round(ix)+minxs-minx]=i.objnum
                    }
                }
                for(let iy=0;iy<maxys-minys;iy++){
                    for(let ix=0;ix<maxxs-minxs;ix++){
                        if(colobj1[iy*Math.floor(maxxs-minxs)+ix]==1&&colobj1[iy*Math.floor(maxxs-minxs)+Math.min(ix+1,Math.floor(maxxs-minxs))]==0){
                            let allowed=false
                            for(let ix1=ix+1;ix1<(maxxs-minxs);ix1++){
                                if(colobj1[iy*Math.floor(maxxs-minxs)+ix1]==1){allowed=true;break}
                            }
                            if(!allowed)continue
                            for(let ix1=ix+1;ix1<(maxxs-minxs)&&colobj1[iy*(maxxs-minxs)+ix1]==0;ix1++){
                                col[(iy+minys-miny)*(maxx-minx)+ix1+minxs-minx]=((maxx-minx)*(maxy-miny)+Math.min(iy,maxys-(iy+minys),ix1,maxxs-(ix1+minxs)))|0
                                colobj[(iy+minys-miny)*(maxx-minx)+ix1+minxs-minx]=(+num+1)
                                objnumout[(iy+minys-miny)*(maxx-minx)+ix1+minxs-minx]=i.objnum
                            }
                        }
                    }
                }
            }
        }else{//for rectangle
            for (let y=i.y|0;y<=i.y+i.h;y++) {
                for (let x=i.x|0;x<=i.x+i.w;x++) {
                    col[(y-miny)*(maxx-minx)+x-minx]=((maxx-minx)*(maxy-miny)+Math.min(y-i.y,i.y+i.h-y,x-i.x,i.x+i.w-x))|0
                    colobj[(y-miny)*(maxx-minx)+x-minx]=(+num+1)
                    objnumout[(y-miny)*(maxx-minx)+x-minx]=i.objnum
                }
            }
        }
    }
}
function gpusetup(){//render it with gpu
    try{
        canvasgl=new OffscreenCanvas(1,1)
        gl=canvasgl.getContext("webgl2")
    }catch(e){enablewebgl=false;return}

    WEBGLmultidraw=gl.getExtension("WEBGL_multi_draw")


    let vertex=`#version 300 es
        precision highp float;

        in vec4 coordinates2;
        in vec4 midle;
        in float num;
        in float objnum;
        out vec4 coordinates2o;
        flat out vec4 midleo;
        out float vnum;
        uniform vec2 max;
        flat out float maxo;
        flat out float objnumo;
        void main(void) {
            gl_Position=vec4((coordinates2.x/max.x)*2.0-1.0,(coordinates2.y/max.y)*2.0-1.0,coordinates2.zw);
            coordinates2o=coordinates2;
            midleo=midle;
            vnum=num;
            maxo=max.x*max.y;
            objnumo=objnum;
        }
    `
    let fragment=`#version 300 es
        precision highp float;
        in float vnum;
        out ivec4 fragColor;
        in vec4 coordinates2o;
        flat in vec4 midleo;
        flat in float maxo;
        flat in float objnumo;
        void main(void) {
            fragColor = ivec4(maxo+distance(coordinates2o,midleo),vnum,objnumo,1);
        }
    `

    let vertShader=gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertShader, vertex);
    gl.compileShader(vertShader);
    let fragShader=gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragShader, fragment);
    gl.compileShader(fragShader);
    if (!gl.getShaderParameter(vertShader,gl.COMPILE_STATUS)) {
        console.log("An error occurred compiling the shaders: " +  gl.getShaderInfoLog(vertShader));
    }
    if (!gl.getShaderParameter(fragShader,gl.COMPILE_STATUS)) {
        console.log("An error occurred compiling the shaders: " +  gl.getShaderInfoLog(fragShader));
    }
    shaderProgram=gl.createProgram();
    gl.attachShader(shaderProgram, vertShader);
    gl.attachShader(shaderProgram, fragShader);
    gl.linkProgram(shaderProgram)
    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        console.log("Error linking shaders:" + gl.getProgramInfoLog(shaderProgram));
    }


    coordinates2=gl.createBuffer()
    num=gl.createBuffer()
    midle=gl.createBuffer()
    objnum=gl.createBuffer()
    max=gl.getUniformLocation(shaderProgram,"max")
    frame=gl.createFramebuffer()
    render=gl.createRenderbuffer()

    vao=gl.createVertexArray();
    gl.bindVertexArray(vao);
    gl.bindBuffer(gl.ARRAY_BUFFER, coordinates2);
    gl.vertexAttribPointer(gl.getAttribLocation(shaderProgram,"coordinates2"), 2, gl.FLOAT,false,0,0)
    gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram,"coordinates2"))
    gl.bindBuffer(gl.ARRAY_BUFFER, num);
    gl.vertexAttribPointer(gl.getAttribLocation(shaderProgram,"num"), 1, gl.FLOAT,false,0,0)
    gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram,"num"))
    gl.bindBuffer(gl.ARRAY_BUFFER, midle);
    gl.vertexAttribPointer(gl.getAttribLocation(shaderProgram,"midle"), 2, gl.FLOAT,false,0,0)
    gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram,"midle"))
    gl.bindBuffer(gl.ARRAY_BUFFER, objnum);
    gl.vertexAttribPointer(gl.getAttribLocation(shaderProgram,"objnum"), 1, gl.FLOAT,false,0,0)
    gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram,"objnum"))
    gl.bindVertexArray(null);
}
function gpuwork(minx,miny,maxx,maxy,myRect,col,colobj,objnumout){
    gl.useProgram(shaderProgram);
    
    let cordinaten=[]
    let midlearr=[]
    let objnumarr=[]
    let numbers=[]
    let num1=0
    let firstst=[]
    let countst=[]
    colobjarr=[]
    for(let i of myRect){
        num1++
        if(i.invisible)continue
        colobjarr.push(i)
        firstst.push(numbers.length)
        let counter=0
        if(typeof(i.x)=="object"){
            const firstx=Math.min(...i.x)
            const firsty=Math.min(...i.y)
            for (let i1=0;i1<i.x.length;i1++){
                cordinaten.push(i.x[i1]-minx,i.y[i1]-miny)
                numbers.push(num1)
                midlearr.push(firstx+i.w/2-minx,firsty+i.h/2-miny)
                counter++
                objnumarr.push(i.objnum)
            }
        }else{
            cordinaten.push(
                i.x-minx,i.y-miny,
                i.x+i.w-minx,i.y-miny,
                i.x+i.w-minx,i.y+i.h-miny,
                i.x-minx,i.h+i.y-miny
            )
            midlearr.push(
                i.x+i.w/2-minx,i.y+i.h/2-miny,
                i.x+i.w/2-minx,i.y+i.h/2-miny,
                i.x+i.w/2-minx,i.y+i.h/2-miny,
                i.x+i.w/2-minx,i.y+i.h/2-miny
            )
            numbers.push(
                num1,
                num1,
                num1,
                num1
            )
            objnumarr.push(
                i.objnum,
                i.objnum,
                i.objnum,
                i.objnum
            )
            counter+=4
        }
        countst.push(counter)
    }
    //generate buffers with values to draw
    const firsts=new Int32Array(firstst)
    const counts=new Int32Array(countst)

    gl.uniform2f(max,maxx-minx,maxy-miny);
    gl.bindVertexArray(vao)
    gl.bindBuffer(gl.ARRAY_BUFFER, coordinates2);
    gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(cordinaten),gl.STREAM_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, midle);
    gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(midlearr),gl.STREAM_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, num);			
    gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(numbers),gl.STREAM_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, objnum);			
    gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(objnumarr),gl.STREAM_DRAW);

    gl.viewport(0,0,maxx-minx,maxy-miny)
    

    gl.bindFramebuffer(gl.FRAMEBUFFER, frame);
    gl.bindRenderbuffer(gl.RENDERBUFFER, render);
    
    //gl.renderbufferStorage(gl.RENDERBUFFER, gl.RG32I,maxx-minx,maxy-miny)
    //gl.RGBA32I
    //gl.renderbufferStorage(gl.RENDERBUFFER, gl.RGB32I,maxx-minx,maxy-miny)
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.RGBA32I,maxx-minx,maxy-miny)
    
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, render);
    
    if(WEBGLmultidraw){
        WEBGLmultidraw.multiDrawArraysWEBGL(gl.TRIANGLE_FAN, firsts, 0, counts, 0, firsts.length);
    }else{
        for(let i2=0;i2<firsts.length;i2++)gl.drawArrays(gl.TRIANGLE_FAN,firsts[i2],counts[i2])
    }
    gl.flush()
    //let arr=new Int32Array((maxy-miny)*(maxx-minx)*2)
    //gl.readPixels(0,0,maxx-minx,maxy-miny, gl.RG_INTEGER, gl.INT, arr);
    //for(let i=0;i<arr.length;i+=2){
    //    col[i/2]=arr[i]
    //    colobj[i/2]=arr[i+1]
    //}

    //let arr=new Int32Array((maxy-miny)*(maxx-minx)*3)
    //gl.readPixels(0,0,maxx-minx,maxy-miny, gl.RGB_INTEGER, gl.INT, arr);
    //for(let i=0;i<arr.length;i+=3){
    //    col[i/3]=arr[i]
    //    colobj[i/3]=arr[i+1]
    //    objnumout[i/3]=arr[i+2]
    //}
    let arr=new Int32Array((maxy-miny)*(maxx-minx)*4)
    gl.readPixels(0,0,maxx-minx,maxy-miny, gl.RGBA_INTEGER, gl.INT, arr);
    for(let i=0;i<arr.length;i+=4){
        col[i/4]=arr[i]
        colobj[i/4]=arr[i+1]
        objnumout[i/4]=arr[i+2]
    }
    gl.bindVertexArray(null)
    gl.bindFramebuffer(gl.FRAMEBUFFER,null);
    gl.bindRenderbuffer(gl.RENDERBUFFER,null);
}
gpusetup()
//!js
</script>


<script id="aiki" async type="javascript/worker">
//js
this.me1={}
this.objcolmap
this.objenemymap
this.m4xfps=60
this.time=0
this.minx=0
this.miny=0
this.maxx=0
this.maxy=0
this.minxnum=0
this.minynum=0
this.int=undefined
this.start=false

Object.defineProperty(me1, 'minx', {get:()=>{return me1.x[minxnum]}});
Object.defineProperty(me1, 'miny', {get:()=>{return me1.y[minynum]}});


Object.defineProperty(me1, 'setx', {set:(num)=>{for(let i=0,min=me1.minx;i<me1.x.length;i++)me1.x[i]+=-min+num}});
Object.defineProperty(me1, 'movex', {set:(num)=>{for(let i=0;i<me1.x.length;i++)me1.x[i]+=num}});
Object.defineProperty(me1, 'sety', {set:(num)=>{for(let i=0,min=me1.miny;i<me1.y.length;i++)me1.y[i]+=-min+num}});
Object.defineProperty(me1, 'movey', {set:(num)=>{for(let i=0;i<me1.y.length;i++)me1.y[i]+=num}});


self.onmessage = function(e) {
    if("debugchanel" in e.data){
        e.data.debugchanel.onmessage=e1=>{
            let str=""
            console.log("%cwebworker run: "+e1.data,'color: orange')
            try{str=eval(e1.data);console.log(str)}catch(e1){e.data.debugchanel.postMessage(e1)}
            try{e.data.debugchanel.postMessage(str)}catch(e1){e.data.debugchanel.postMessage(e1)}
        }
    }
    if("start" in e.data&&e.data.start==true){
        if(this.int!=undefined)clearInterval(this.int);
        this.int=setInterval(func,1000/m4xfps)
        start=true
    }
    if("stop" in e.data&&e.data.stop==true){
        if(this.int!=undefined)clearInterval(this.int);
        start=false
    }
    if("eval" in e.data){
        eval(e.data.eval)
    }
    if("debug" in e.data&&e.data.debug==true){
        console.log(this)
        console.log(me1)
        console.log(objcolmap)
    }
    if("update" in e.data){
        if("dir" in e.data.update){
            me1.dir=new Float64Array(e.data.update.dir)
            me1.shareddir=e.data.update.dir
        }
        if("dmg" in e.data.update){
            me1.dmg=new Uint32Array(e.data.update.dmg)
            me1.shareddmg=e.data.update.dmg
        }
        if("lastupdatetime" in e.data.update){
            me1.lastupdatetime=new Float64Array(e.data.update.lastupdatetime)
            me1.sharedlastupdatetime=e.data.update.lastupdatetime
        }
        if("x" in e.data.update){
            me1.x=new Float64Array(e.data.update.x)
            me1.sharedx=e.data.update.x
            let minxtemp=Infinity
            for(let i in me1.x)if(minxtemp>me1.x[i]){minxtemp=me1.x[i];minxnum=i}
            me1.w=Math.max(0,Math.max(...me1.x)-Math.min(...me1.x));
        }
        if("y" in e.data.update){
            me1.y=new Float64Array(e.data.update.y)
            me1.sharedy=e.data.update.y
            let minytemp=Infinity
            for(let i in me1.y)if(minytemp>me1.y[i]){minytemp=me1.y[i];minynum=i}
            me1.h=Math.max(0,Math.max(...me1.y)-Math.min(...me1.y));
        }
        if("velo" in e.data.update){
            me1.velo=new Float64Array(e.data.update.velo)
            me1.sharedvelo=e.data.update.velo
        }
        if("minx" in e.data.update){
            minx=e.data.update.minx
        }
        if("miny" in e.data.update){
            miny=e.data.update.miny
        }
        if("maxx" in e.data.update){
            maxx=e.data.update.maxx
        }
        if("maxy" in e.data.update){
            maxy=e.data.update.maxy
        }
        if("objnum" in e.data.update){
            me1.objnum=e.data.update.objnum
        }
        if("kitype" in e.data.update){
            me1.kitype=e.data.update.kitype
        }
        if("code" in e.data.update){
            self.func=new Function("",e.data.update.code.replace(/^.*(\n|\r)|(\n|\r).*$/g,""))
        }
        if("updatet" in e.data.update){
            me1.updatet=new Uint8Array(e.data.update.updatet)
            me1.sharedupdatet=e.data.update.updatet
        }
        if("colobjnum" in e.data.update){
            me1.colobjnum=new Uint32Array(e.data.update.colobjnum)
            me1.sharedcolobjnum=e.data.update.colobjnum
        }
        if("m4xfps" in e.data.update){
            m4xfps=Math.max(e.data.update.m4xfps,0.00001)
            if(start&&e.data.update.objcolmap!=undefined){if(this.int!=undefined)clearInterval(this.int);this.int=setInterval(func,1000/m4xfps)}
        }
        if("objcolmap" in e.data.update){
            objcolmap=new Uint8Array(e.data.update.objcolmap)
            if(start&&e.data.update.objcolmap!=undefined){if(this.int!=undefined)clearInterval(this.int);this.int=setInterval(func,1000/m4xfps)}
        }
        if("objenemymap" in e.data.update){
            objenemymap=new Uint8Array(e.data.update.objenemymap)
            objenemysharedmap=e.data.update.objenemymap
        }
    }
}
//!js
</script>

<script id="neuroaiki" async type="javascript/worker">
//js
this.objarrays=[]
this.objcolmap
this.objenemymap
this.m4xfps=60
this.time=0
this.minx=0
this.miny=0
this.maxx=0
this.maxy=0
this.network=""
this.minxnum=0
this.minynum=0
this.int=undefined
this.start=false

let finki
let kiworstfitnes
let kipriorisirung=[1,0.001]
let kipriorisirungmax
let oldkeystimemax=120
let resetafter=60000
let resetcounter=0
let neat=null
let viewdistki=60
let viewscaledown=5

self.onclose = function() {
    if(typeof(neat)!=undefined&&neat instanceof NEAT){
        postMessage({havenetwork:true,network:JSON.stringify(neat.export())})
    }else{
        postMessage({havenetwork:false})
    }
}
self.onmessage = function(e) {
    if("debugchanel" in e.data){
        e.data.debugchanel.onmessage=e1=>{
            let str=""
            console.log("%cwebworker run: "+e1.data,'color: orange')
            try{str=eval(e1.data);console.log(str)}catch(e1){e.data.debugchanel.postMessage(e1)}
            try{e.data.debugchanel.postMessage(str)}catch(e1){e.data.debugchanel.postMessage(e1)}
        }
    }
    if("stop" in e.data&&e.data.stop==true){
        if(this.int!=undefined)clearInterval(this.int);
        start=false
        this.objarrays=[]
    }
    if("sendnetwork" in e.data&&e.data.sendnetwork==true){
        if(typeof(neat)!=undefined&&neat instanceof NEAT){
            postMessage({havenetwork:true,network:JSON.stringify(neat.export())})
        }else{
            postMessage({havenetwork:false})
        }
    }
    if("eval" in e.data){
        eval(e.data.eval)
    }
    if("debug" in e.data&&e.data.debug==true){
        console.log(this)
        console.log(objarrays)
        console.log(neat)
    }
    if("die" in e.data&&e.data.die==true){
        objarrays[e.data.num].dead=true
        console.log(e.data.num+" died (from outside)")
        objarrays[e.data.num].keys[0]=0
        objarrays[e.data.num].keys[1]=0
        objarrays[e.data.num].keys[2]=0
        objarrays[e.data.num].keys[3]=0
        objarrays[e.data.num].keys[4]=0
        objarrays[e.data.num].newtime=performance.now()
        objarrays[e.data.num].oldkeystime=0
        objarrays[e.data.num].setx=130
        objarrays[e.data.num].sety=580
    }
    if("update" in e.data){
        if("minx" in e.data.update){
            minx=e.data.update.minx
        }
        if("miny" in e.data.update){
            miny=e.data.update.miny
        }
        if("maxx" in e.data.update){
            maxx=e.data.update.maxx
        }
        if("maxy" in e.data.update){
            maxy=e.data.update.maxy
        }
        if("code" in e.data.update){
            let t=Object.keys(e.data.update.code)
            for(let i of t){
                let param=e.data.update.code[i].replace(/^function.*\(|\).*((\n|\r).*)*$/g,"").split(",")
                self[i]=new Function(...param,e.data.update.code[i].replace(/^.*(\n|\r)|(\n|\r).*$/g,""))
            }
        }
        if("neatcode" in e.data.update){
            (function(){
                eval.apply(this, arguments);
            }(e.data.update.neatcode))//global running
        }
        if("m4xfps" in e.data.update){
            m4xfps=Math.max(e.data.update.m4xfps,0.00001)
            if(start&&e.data.update.objcolmap!=undefined){if(this.int!=undefined)clearInterval(this.int);this.int=setInterval(func,1000/m4xfps)}
        }
        if("objcolmap" in e.data.update){
            objcolmap=new Uint8Array(e.data.update.objcolmap)
            if(start&&e.data.update.objcolmap!=undefined){if(this.int!=undefined)clearInterval(this.int);this.int=setInterval(func,1000/m4xfps)}
        }
        if("objenemymap" in e.data.update){
            objenemymap=new Uint8Array(e.data.update.objenemymap)
            objenemysharedmap=e.data.update.objenemymap
        }
        if("finki" in e.data.update){
            finki=e.data.update.finki
        }
        if("keyshared" in e.data.update){
            keysharedarr=new Float64Array(e.data.update.keyshared)
            keyshared=e.data.update.keyshared
        }
        if("network" in e.data.update&&e.data.update.network!=""){
            network=JSON.parse(e.data.update.network)
        }
    }
    if("add" in e.data){
        //save what element it is
        let num="num" in e.data.add?e.data.add.num:objarrays.length
        if(objarrays[num]==null){
            objarrays[num]={}
            if(start)kistart()
        }
        let me1=objarrays[num]
        if("dir" in e.data.add){
            me1.dir=new Float64Array(e.data.add.dir)
            me1.shareddir=e.data.add.dir
        }
        if("lastupdatetime" in e.data.add){
            me1.lastupdatetime=new Float64Array(e.data.add.lastupdatetime)
            me1.sharedlastupdatetime=e.data.add.lastupdatetime
        }
        if("x" in e.data.add){
            me1.x=new Float64Array(e.data.add.x)
            me1.sharedx=e.data.add.x
            let minxtemp=Infinity
            for(let i in me1.x)if(minxtemp>me1.x[i]){minxtemp=me1.x[i];minxnum=i}
            me1.w=Math.max(0,Math.max(...me1.x)-Math.min(...me1.x));
            Object.defineProperty(me1, 'minx', {get:()=>{return me1.x[minxnum]}});
            Object.defineProperty(me1, 'setx', {set:(num)=>{for(let i=0,min=me1.minx;i<me1.x.length;i++)me1.x[i]+=-min+num}});
            Object.defineProperty(me1, 'movex', {set:(num)=>{for(let i=0;i<me1.x.length;i++)me1.x[i]+=num}});
        }
        if("y" in e.data.add){
            me1.y=new Float64Array(e.data.add.y)
            me1.sharedy=e.data.add.y
            let minytemp=Infinity
            for(let i in me1.y)if(minytemp>me1.y[i]){minytemp=me1.y[i];minynum=i}
            me1.h=Math.max(0,Math.max(...me1.y)-Math.min(...me1.y));
            Object.defineProperty(me1, 'miny', {get:()=>{return me1.y[minynum]}});
            Object.defineProperty(me1, 'sety', {set:(num)=>{for(let i=0,min=me1.miny;i<me1.y.length;i++)me1.y[i]+=-min+num}});
            Object.defineProperty(me1, 'movey', {set:(num)=>{for(let i=0;i<me1.y.length;i++)me1.y[i]+=num}});
        }
        if("velo" in e.data.add){
            me1.velo=new Float64Array(e.data.add.velo)
            me1.sharedvelo=e.data.add.velo
        }
        if("dmg" in e.data.add){
            me1.dmg=new Uint32Array(e.data.add.dmg)
            me1.shareddmg=e.data.add.dmg
        }
        if("statsnum" in e.data.add){
            me1.statsnum=new Uint32Array(e.data.add.statsnum)
            me1.sharedstatsnum=e.data.add.statsnum
        }
        if("objnum" in e.data.add){
            me1.objnum=e.data.add.objnum
        }
        if("kitype" in e.data.add){
            me1.kitype=e.data.add.kitype
        }
        if("updatet" in e.data.add){
            me1.updatet=new Uint8Array(e.data.add.updatet)
            me1.sharedupdatet=e.data.add.updatet
        }
        if("colobjnum" in e.data.add){
            me1.colobjnum=new Uint32Array(e.data.add.colobjnum)
            me1.sharedcolobjnum=e.data.add.colobjnum
        }
        if("graviins" in e.data.add){
            me1.graviins=new Float64Array(e.data.add.graviins)
            me1.sharedgraviins=e.data.add.graviins
        }
        if("inwater" in e.data.add){
            me1.inwater=new Uint8Array(e.data.add.inwater)
            me1.sharedinwater=e.data.add.inwater
        }
        if("keys" in e.data.add){
            me1.keys=new Float64Array(e.data.add.keys)
            me1.sharedkeys=e.data.add.keys
        }
    }
    if("start" in e.data&&e.data.start==true&&objarrays.length>0){
        if(this.int!=undefined)clearInterval(this.int);
        this.int=setInterval(kiloop,1000/m4xfps)
        if(!start)kistart()
        start=true
    }
}


function kistart(){
    let exp=null
    if(typeof(neat)!=undefined&&neat instanceof NEAT)exp=neat.export()
    //sort them after score

    let config = {
        model: [
            //{nodeCount: 8+8*4, type: "input"},
            {nodeCount: 8+((viewdistki*2/viewscaledown)*(viewdistki*2/viewscaledown)), type: "input"},
            //{nodeCount: 6, type: "output", activationfunc: activation.RELU}
            {nodeCount: 32, type: "output", activationfunc: activation.RELU}
        ],
        mutationRate: 0.05,
        crossoverMethod: crossover.RANDOM,
        mutationMethod: mutate.RANDOM,
        populationSize: objarrays.length
    }; 

    //input up down right left x y gravix graviy
    //man solte noch ob die nachbarten obj enemys sind bzw solid und type

    neat=new NEAT(config);
    //console.log(neat)
    //load the best genes first
    if(network!=""&&network.length==2&&network[1][0]!=null)for(let i=0;i<Math.min(objarrays.length,network[1].length);i++)neat.creatures[i].setFlattenedGenes(network[1][i])
    if(exp!=null&&exp[1][0]!=null)for(let i=0;i<Math.min(objarrays.length,exp[1].length);i++)neat.creatures[i].setFlattenedGenes(exp[1][i])
    //console.log(objarrays.length)
    //console.log(neat)
    kiworstfitnes=Math.hypot(maxx-minx,maxy-miny)
    kipriorisirungmax=0
    for(let i of kipriorisirung){kipriorisirungmax+=i}
    neat.feedForward()
    let kitime=performance.now()
    for(let i of objarrays){
        i.newtime=kitime
        i.kitime=kitime
        i.oldkeystime=0
    }
}
//!js
</script>

<script id="neat">
    /*
	Author: ExtensionShoe
	Date: 30/08/2019
	License: MIT
*/
function NEAT(config) {
	this.creatures = [];
	this.oldCreatures = [];
	this.model = config.model;
	this.exportModel = [];
	this.populationSize = config.populationSize || 500;
	this.mutationRate = config.mutationRate || 0.05;
	this.crossoverMethod = config.crossoverMethod || crossover.RANDOM;
	this.mutationMethod = config.mutationMethod || mutate.RANDOM;
	this.generation = 0;

	for (let i = 0; i < this.model.length; i++) { // Sanitize the model.
		let data = Object.assign({}, this.model[i]);
		if (this.model[i].activationfunc) {
			data.activationfunc = data.activationfunc.name;
			this.exportModel.push(data);
		} else {
			this.exportModel.push(data);
		}
	}

	for (let i = 0; i < this.populationSize; i++) { // Create the creatures.
		this.creatures.push(new Creature(this.model));
	}

	this.mutate = function () { // Parses every creature's genes passes them to the mutation function and sets their new (mutated) genes.
		for (let i = 0; i < this.populationSize; i++) {
			let genes = this.creatures[i].flattenGenes();
			genes = this.mutationMethod(genes, this.mutationRate);
			this.creatures[i].setFlattenedGenes(genes);
		}
	}

	this.crossover = function () { // Takes two creature's genes flattens them and passes them to the crossover function.
		for (let i = 0; i < this.populationSize; i++) {
			this.oldCreatures = Object.assign([], this.creatures);
			let parentx = this.pickCreature();
			let parenty = this.pickCreature();

			let genes = this.crossoverMethod(parentx.flattenGenes(), parenty.flattenGenes());
			this.creatures[i].setFlattenedGenes(genes);
		}
	}

	this.pickCreature = function () { // Normalizes every creature's score (fitness) and and returns a creature based on their fitness value.
		let sum = 0;
		for (let i = 0; i < this.oldCreatures.length; i++) {
			sum += Math.pow(this.oldCreatures[i].score, 2);
		}

		for (let i = 0; i < this.oldCreatures.length; i++) {
			this.oldCreatures[i].fitness = Math.pow(this.oldCreatures[i].score, 2) / sum;
		}
		let index = 0;
		let r = Math.random();
		while (r > 0) {
			r -= this.oldCreatures[index].fitness;
			index += 1;
		}
		index -= 1;
		return this.oldCreatures[index];
	}

	this.setFitness = function (fitness, index) { // Sets a creature's score. This will then be normalized for actual fitness value.
		this.creatures[index].score = fitness;
	}

	this.feedForward = function () { // Feeds forward every creature's network.
		for (let i = 0; i < this.creatures.length; i++) {
			this.creatures[i].feedForward();
		}
	}

	this.doGen = function () { // Does 1 fast generation with crossover and mutation.
		this.crossover();
		this.mutate();
		this.generation++;
		console.log('Generation: ' + this.generation);
	}

	this.bestCreature = function () { // Returns the index of the best creature from the previous generation.
		let index = 0;
		let max = -Infinity;
		for (let i = 0; i < this.oldCreatures.length; i++) {
			if (this.oldCreatures[i].fitness > max) {
				max = this.oldCreatures[i].fitness;
				index = i;
			}
		}
		return index;
	}

	this.getDesicions = function () { // Returns every creature's desicion index in an array.
		let result = [];

		for (let i = 0; i < this.creatures.length; i++) {
			result.push(this.creatures[i].desicion());
		}
		return result;
	}

	this.setInputs = function (array, index) { // Sets the inputs of the creature indexed as "index".
		this.creatures[index].setInputs(array);
	}

	this.export = function (index) {
		let data = [];
		data.push(JSON.parse(JSON.stringify(this.exportModel)));
		data.push([]);
		if (index) {
			data[1].push(this.creatures[index].flattenGenes());
		} else {
			for (let i = 0; i < this.populationSize; i++) {
				data[1].push(this.creatures[i].flattenGenes());
			}
		}
		return data;
	}

	this.import = function (data) {
		if (JSON.stringify(data[0]) === JSON.stringify(this.exportModel)) {
			console.log('Importing ' + data[1].length + ' creature(s)');
			for (let i = 0; i < data[1].length; i++) {
				let newCreature = new Creature(this.model);
				newCreature.setFlattenedGenes(data[1][i]);
				this.creatures.push(newCreature);
				this.populationSize++;
			}
		} else {
			throw "Invalid model!";
		}
	}

	this.getTensorflowModel = function(index) { // Generate the requested tensorflow model.
		if (index) {
			// Generate the model for the index provided.
			return this.creatures[index].network.getTensorflowModel();
		} else {
			// Generate the model the best performing creature.
			return this.creatures[this.bestCreature()].network.getTensorflowModel();
		}
	}
}

function Creature(model) {
	this.network = new Network(model); // Init the network

	this.fitness = 0;
	this.score = 0;

	this.flattenGenes = function () { // Flattens the genes of the creature's genes and returns them as an array.
		let genes = [];

		for (let i = 0; i < this.network.layers.length - 1; i++) {
			for (let w = 0; w < this.network.layers[i].nodes.length; w++) {
				for (let e = 0; e < this.network.layers[i].nodes[w].weights.length; e++) {
					genes.push(this.network.layers[i].nodes[w].weights[e]);
				}
			}

			for (let w = 0; w < this.network.layers[i].bias.weights.length; w++) {
				genes.push(this.network.layers[i].bias.weights[w]);
			}
		}

		return genes;
	}

	this.setFlattenedGenes = function (genes) { // Sets an array of weights as the creature's genes.
		for (let i = 0; i < this.network.layers.length - 1; i++) {
			for (let w = 0; w < this.network.layers[i].nodes.length; w++) {
				for (let e = 0; e < this.network.layers[i].nodes[w].weights.length; e++) {
					this.network.layers[i].nodes[w].weights[e] = genes[0];
					genes.splice(0, 1);
				}
			}

			for (let w = 0; w < this.network.layers[i].bias.weights.length; w++) {
				this.network.layers[i].bias.weights[w] = genes[0];
				genes.splice(0, 1);
			}
		}
	}

	this.feedForward = function () { // Feeds forward the creature's network.
		this.network.feedForward();
	}

	this.setInputs = function (inputs) { // Sets the inputs of the creature.
		this.network.layers[0].setValues(inputs);
	}

	this.desicion = function () { // Some spaghetti code that returns the desicion of the creature.
		let index = -1; 
		let max = -Infinity;
		for (let i = 0; i < this.network.layers[this.network.layers.length - 1].nodes.length; i++) {
			if (this.network.layers[this.network.layers.length - 1].nodes[i].value > max) {
				max = this.network.layers[this.network.layers.length - 1].nodes[i].value;
				index = i;
			}
		}
		return index;
	}
}

function Network(model) { // Neural Network.
	this.layers = [];
	this.model = model;

	for (let i = 0; i < model.length; i++) { // Init all the layers.
		this.layers.push(new Layer(model[i].nodeCount, model[i].type, model[i].activationfunc));
	}

	for (let i = 0; i < this.layers.length - 1; i++) { // Connect the layers to each other.
		this.layers[i].connect(this.layers[i + 1].nodes.length);
	}

	this.feedForward = function () { // Feeds forward the network.
		for (let i = 0; i < this.layers.length - 1; i++) {
			this.layers[i].feedForward(this.layers[i + 1]);
		}
	}

	this.getTensorflowModel = function () { // Generates a tensorflow model from the current network.
		
		// Collect the weights from each layer in the network.
		let weights = [];
		for(let i = 0; i < this.layers.length - 1; i++) {
			let weights_ = [];
			for(let j = 0; j < this.layers[i].nodes.length; j++) {
				weights_.push(this.layers[i].nodes[j].weights);
			}
			weights.push(weights_);
		}

		// Initialize the input and hidden layers.
		let input = tf.input({shape: [this.model[0].nodeCount]});
		let previous = input;
		for(let i = 1; i < this.model.length - 1; i++) {
			previous = tf.layers.dense({units: this.model[i].nodeCount, activation: 'relu'}).apply(previous);
		}
		// Initialize the output layer.
		let output = tf.layers.dense({units: this.model[this.model.length - 1].nodeCount, activation: 'softmax'}).apply(previous);

		// Create the model with random weights.
		let model = tf.model({inputs: input, outputs: output});

		// Set the weights of the model to the weights found by NEAT.
		for(let i = 1; i < this.model.length; i++) {
			model.layers[i].setWeights([tf.tensor(weights[i - 1], [weights[i-1].length, weights[i-1][0].length], dtype="float32"), tf.fill([this.model[i].nodeCount],0, dtype="float32")]);
		}

		return model;
	}
}

function Layer(nodeCount, type, activationfunc) { // A layer component of a network with nodes and bias node.
	this.nodes = [];
	this.bias = undefined;
	this.type = type;
	this.activationfunc = activationfunc;

	for (let i = 0; i < nodeCount; i++) { // Inits  nodes.
		this.nodes.push(new Node());
	}

	if (this.type !== "output") this.bias = new Node();

	this.connect = function (count) { // Connects one layer to another.
		for (let i = 0; i < this.nodes.length; i++) {
			this.nodes[i].initWeights(count);
		}

		if (this.bias !== undefined) this.bias.initWeights(count);
	}

	this.feedForward = function (layer) { // Feeds forward the layers values to the specified layer.
		for (let i = 0; i < this.bias.weights.length; i++) {
			layer.nodes[i].value = 0;
		}

		for (let i = 0; i < this.nodes.length; i++) {
			for (let w = 0; w < this.nodes[i].weights.length; w++) {
				layer.nodes[w].value += this.nodes[i].value * this.nodes[i].weights[w];
			}
		}

		for (let w = 0; w < this.bias.weights.length; w++) {
			layer.nodes[w].value += this.bias.weights[w];
		}

		if (layer.activationfunc.name !== "SOFTMAX") for (let w = 0; w < layer.nodes.length; w++) layer.nodes[w].value = layer.activationfunc(layer.nodes[w].value);
		else layer.setValues(layer.activationfunc(layer.getValues()));
	}

	this.getValues = function () { // Returns the values of the nodes in the layer as an array.
		let result = [];
		for (let i = 0; i < this.nodes.length; i++) {
			result.push(this.nodes[i].value);
		}
		return result;
	}

	this.setValues = function (values) { // Sets an array as the nodes values.
		for (let i = 0; i < this.nodes.length; i++) {
			this.nodes[i].value = values[i];
		}
	}
}

function Node() { // A Node.
	this.value = 0;
	this.weights = [];


	this.initWeights = function (count) { // Randomly initalize weights.
		for (let i = 0; i < count; i++) {
			this.weights.push((Math.random() * 2) - 1);
		}
	}
}

activation = { // Supported activation functions.
	RELU: function (x) {
		if (x > 0) return x;
		else return 0;
	},
	TANH: function (x) {
		return Math.tanh(x);
	},
	SIGMOID: function (x) {
		return (1 / (1 + Math.exp(-x)));
	},
	LEAKY_RELU: function (x) {
		if (x > 0) return x;
		else return (x * 0.01);
	},
	SOFTMAX: function (array) {
		let sum = 0;
		let result = [];
		for (let i = 0; i < array.length; i++) {
			sum += Math.exp(array[i]);
		}
		for (let i = 0; i < array.length; i++) {
			result.push(Math.exp(array[i]) / sum);
		}
		return result;
	}
}

crossover = { // Crossover methods.
	RANDOM: function (genesx, genesy) { // Randomly take genes from parentx or parenty and return newly created genes.
		let newGenes = [];

		for (let i = 0; i < genesx.length; i++) {
			if (Math.random() < 0.5) newGenes.push(genesx[i]);
			else newGenes.push(genesy[i]);
		}

		return newGenes;
	},
	SLICE: function (genesx, genesy) { // Takes a starting and an ending point in parentx's genes removes the genes in between and replaces them with parenty's genes. (How nature does it.)
		let start = Math.floor(Math.random() * (genesx.length));
		let end = Math.floor(Math.random() * (genesx.length - start + 2)) + start + 1;
		let cutPart = genesx.splice(start, end);

		Array.prototype.splice.apply(genesy, [start, cutPart.length].concat(cutPart));

		return genesy;

	}
}

mutate = { // Mutation function (More to come!).
	RANDOM: function (genes, mutationRate) { // Randomly sets the weights to a completely random value.
		for (let i = 0; i < genes.length; i++) {
			if (Math.random() < mutationRate) genes[i] = (Math.random() * 2) - 1;
		}
		return genes;
	}
}
</script>
<style>
body,html,canvas{
    margin:0;
}
body{
    height:100vh;
    display:grid;
    grid-template-columns:auto;
    grid-template-rows:auto;
    overflow-x: hidden;
    }
#canvas{
    position:fixed;
    z-index: 0;
}
#canvasb{
    position:fixed;
    z-index:-2
}
#canvasshadow{
    position:fixed;
    z-index:-3
}
#canvasbshadow{
    position:fixed;
    z-index:-4
}
.menu{
    margin-left:30vw;
    margin-right:30vw;
    z-index:1;
    }
.menu:focus{
    border: 1px solid;
}
.presetask{
    margin-left:30vw;
    margin-right:30vw;
    z-index:2;
    }
.presetask:focus{
    border: 1px solid;
}
#buildmenu{
    position:absolute;
    bottom:0;
    height:10vh;
    width: 100vw;
    overflow-x:auto;
    overflow-y:hidden;
    border-top:1px solid gray;
    white-space: nowrap;
}
#buildmenu, div{
    z-index:2;
}
#optionmenu{
    position:absolute;
    bottom:10vh;
    top:0;
    right:0;
    overflow-x:auto;
    user-select:none;
}
#optionmenu, input{
    z-index:3;
}
.menues{
    z-index: 1;
}
#buildmenu div:focus{
    border-left: 1px solid blue;
    border-right: 1px solid blue;
}
h1,h2,h3{
    margin: 0;
    overflow: hidden;
}
.desyncedcolor{
    background-color: white;
}

</style>
</head>
<body>
    <button accesskey="s" title="need main createobj and game" disabled="true" class="menu" id="start" autofocus>Start</button>
    <button accesskey="k" title="need main" disabled="true" class="menu" id="keymap">Keymap</button>
    <button accesskey="l" title="need main (save) and createobj" disabled="true" class="menu" id="save">Load&Save</button>
    <button accesskey="o" title="need main" disabled="true" class="menu" id="settings">Setting</button>
    <button accesskey="w" title="need main and multiplayer" disabled="true" class="menu" id="webrtc">Webrtc</button>
    <button accesskey="b" title="need main createobj and build" disabled="true" class="menu" id="build">Build</button>
    <button accesskey="c" title="need main" disabled="true" class="menu" id="close">Close</button>
</body>